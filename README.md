# Ալգորիթմական լեզու

## Ներածություն

Սա _Ալգորիթմական_ լեզուն է, ավելի ճիշտ՝ դրա մի ձևափոխությունը, որն ինչ-որ ժամանակ 
օգտագործվում էր դպրոցական «Ինֆորմատիկա և հաշվողական տեխնիկայի հիմունքներ» առարկայի 
դասագրքերում։ Որքան որ ես տեղյակ եմ, այս լեզուն _հայերեն_ իրականացում չի ունեցել. 
այն օգտագործվել է միայն թղթին կամ գրատախտակին ալգորիթմների նկարագրության և 
ուսումնասիրության համար։

Բայց իմ այս նախագիծով նպատակ չունեմ հասնել Ալգորիթմական լեզվի լիարժեք իրականացման, 
ինչպիսին է, օրինակ, նույն լեզվի ռուսական [КуМир](https://www.niisi.ru/kumir/) տարբերակը։
Սա պարզապես խաղալիք է, որը ես օգտագործել եմ նախ՝ [Կոտլին](https://kotlinlang.org/) 
լեզուն սովորելու, ապա՝ Ջավա վիտուալ մեքենայի (JVM) հրամանների համակարգին ծանոթանալու 
համար ([BCEL](https://commons.apache.org/proper/commons-bcel/) գրադարանիի միջոցով)։

Ես իրականացնում եմ դասական _մեկ անցումով_ կոմպիլյատոր, որը մուտքում ստանում է 
_Ալգորիթմական_ լեզվով գրված ծրագիր և ստեղծում է Ջավա վիրտուալ մեքենայի _բայթ-կոդ_։
Օրինակ, ահա `Ողջույններ.ալգ` ֆայլում մի ծրագիր է, որի երկու ալգորիթմները աշխարհին 
ողջունում են հայերենով և իտալերենով.

```
ԾՐԱԳԻՐ Ողջույններ

ԱԼԳՈՐԻԹՄ հայերեն
ՍԿԻԶԲ
    արտածելՏեքստ(«Ողջո՜ւյն, աշխա՛րհ։»)
ՎԵՐՋ

ԱԼԳՈՐԻԹՄ italiano
ՍԿԻԶԲ
    արտածելՏեքստ(«Ciao, mondo!»)
ՎԵՐՋ

ԿԱՏԱՐԵԼ
    հայերեն();
    italiano()
ԱՎԱՐՏ
```

Այս կոմպիլյացիայից ծնվում է `Ողջույններ.class` ֆայլը, որի պարունակությունը կարող ենք
վերծանել Ջավայի դիզասեմբլերով.

```
$ javap -c Ողջույններ.class
public class Ողջույններ {
  public static void հայերեն();
    Code:
       0: ldc           #8                  // String Ողջո՜ւյն, աշխա՛րհ։
       2: invokestatic  #14                 // Method Algorithmic.printText:(Ljava/lang/String;)V
       5: return

  public static void italiano();
    Code:
       0: ldc           #19                 // String Ciao, mondo!
       2: invokestatic  #14                 // Method Algorithmic.printText:(Ljava/lang/String;)V
       5: return

  public static void main(java.lang.String[]);
    Code:
       0: invokestatic  #22                 // Method հայերեն:()V
       3: invokestatic  #24                 // Method italiano:()V
       6: return
}
```

Կատարելու համար պետք է _classpath_-ում ունենալ նաև `Algorithmic.class` ֆայլը, որը
պարունակում է Ալգորիթմական լեզվի ներդրված ֆունկցիաները. ներմուծում/արտածում, մաթեմատիկա,
տեքստային գործողություններ և այլն։

```
$ java Ողջույններ
Ողջո՜ւյն, աշխա՛րհ։
Ciao, mondo!
```


## Քերականություն

_Ալգորիթմական_ լեզվի քերականությունը, այստեղ բերված տարբերակով, իր վրա կրում 
է Ալգոլ, Սի, Բեյսիկ, Օբերոն լեզուների ազդեցությունը։ Կոմպիլյացիայի միավորը 
`ԾՐԱԳԻՐ`-ն է, որը բաղկացած է `ԱԼԳՈՐԻԹՄ`-ներից և պարտադիր կատարվող բլոկից։ 
Ալգորիթմում (դա ենթածրագիրն է) կարելի է հայտարարել `ԻՐԱԿԱՆ`, `ՏԵՔՍՏ` և `ԲՈՒԼՅԱՆ` 
տիպի փոփոխականներ։ _Ղեկավարող կառուցվածքները_ կամ _հրամանները_ չորսն են. _վերագրում_ 
(`:=`), _ճյուղավորում_ (`ԵԹԵ`), _կրկնություն_ (`ՔԱՆԻ ԴԵՌ`) և _արդյունքի վերադարձ_ 
(`ԱՐԴՅՈՒՆՔ`)։ Հրամաններն իրարից բաժանվում են կետ-ստորակետ (`;`) նիշով: Այդ հրամաններում 
օգտագործվող արտահայտությունները կարող են պարունակել _թվաբանական_ (`+`, `-`, `*`, `/`), 
_համեմատման_ (`=`, `<>`, `>`, `>=`, `<`, `<=`) և _տրամաբանական_ (`ԵՎ`, `ԿԱՄ`, `ՈՉ`) 
գործողություններ։ Փոփոխականների և ալգորիթմների անունները իդենտիֆիկատորներ են, որոնք 
սկսվում են տառով և բաղկացած են տառերից ու թվանշաններից։ Դրանց մեջ կարող են օգտագործվել 
նաև հայերենի առոգանության նշանները` `՞`, `՜`, `՛`, որոնք պարզապես կանտեսվեն։   

Ահա Ալգորիթմական լեզվի ամբողջ քերականությունը՝ Բեկուսի-Նաուրի ընդլայնված գրառմամբ (EBNF).

```
Program = 'ԾՐԱԳԻՐ' ԱՆՈՒՆ { Algorithm } 'ԿԱՏԱՐԵԼ' [StatementList] 'ԱՎԱՐՏ'.
Algorithm = 'ԱԼԳՈՐԻԹՄ' [Type] ԱՆՈՒՆ [Parameters] 
            ( 'ՍՏՈՐԵՎ' | DeclarationList 'ՍԿԻԶԲ' [StatementList] 'ՎԵՐՋ').
Parameters = '(' Type ԱՆՈՒՆ {',' Type ԱՆՈՒՆ} ')'.
DeclarationList = Declaration {';' Declaration}.
Declaration = Type ԱՆՈՒՆ {',' ԱՆՈՒՆ}.
Type = 'ԻՐԱԿԱՆ' | 'ՏԵՔՍՏ' | 'ԲՈՒԼՅԱՆ'. 
StatementList = Statement {';' Statement}.
Statement = ԱՆՈՒՆ ':=' Expression
    | 'ԵԹԵ' Expression 'ԱՊԱ' StatementList
      {'ԻՍԿ' 'ԵԹԵ' Expression 'ԱՊԱ' StatementList}
      ['ԱՅԼԱՊԵՍ' StatementList] 'ԱՎԱՐՏ'
    | 'ՔԱՆԻ' 'ԴԵՌ' Expression 'ԱՊԱ' StatementList 'ԱՎԱՐՏ'
    | 'ԱՐԴՅՈՒՆՔ' Expression
    | ԱՆՈՒՆ '(' [ExpressionList] ')'.
ExpressionList = Expression {',' Expression}.
Expression = Disjunction.
Disjunction = Conjunction {'ԿԱՄ' Conjunction}.
Conjunction = Equality {'ԵՎ' Equality}.
Equality = Comparison [('=' | '<>') Comparison].
Comparison = Addition [('>' | '>=' | '<' | '<=') Addition].
Addition = Multiplication {('-' | '+') Multiplication}.
Multiplication = Factor {('*' | '/') Factor}.
Factor = NUMBER | TEXT | ԱՆՈՒՆ
    | ('+' | '-') Factor
    | ԱՆՈՒՆ '(' [ExpressionList] ')'
    | '(' Expression ')'
    | 'ՃԻՇՏ' | 'ԿԵՂԾ'.
```


## Իրականացում

Ալգորիթմական լեզվի իրականացումը բաղկացած է երեք փաթեթներից. 
1. `algorithmic.ast` -- փաթեթում սահմանված են _վերլուծության ծառի_ բաղադրիչները։
2. `algorithmic.parser` -- փաթեթում իրականացված է _շարահյուսական վերլուծիչը_։
3. `algorithmic.compiler` -- փաթեթում իրականացված է _բայթ-կոդի գեներատորը_։


### Վերլուծության ծառ

Ալգորիթմական լեզվով գրված ծրագիրը կոմպիլյացնելիս շարահյուսական վերլուծիչը
կառուցում է _աբստրակտ քերականական ծառ_ (_abstract syntax tree_, AST)։ Այդ 
ծառի հանգույցները նկարագրող դասերը սահմանված են `algorithmic.ast` փաթեթում։
Ամենախոշոր միավորը _ծրագիրը_ ներկայացնող դասն է.

```kotlin
class Program(
        val name: String,                // ծրագրի անունը
        val algorithms: List<Algorithm>, // ալգորիթմների ցուցակը
        val body: Statement              // մարմինը՝ պարտադիր կատարվող բլոկը
    )
```

Ծրագիրն իր մեջ պարունակում է _ալգորիթմներ_, որոնք ներկայացնում են `Algorithm` դասով.

```kotlin
class Algorithm(
        val name: String,             // անունը
        val returnType: Type,         // արդյունքի տիպը
        val parameters: List<Symbol>, // պարամետրերը
        val body: Statement           // մարմինը
    ) {
        val locals = arrayListOf<Symbol>() // լոկալ անունները
}
```

Թարգմանության ժամանակ ալգորիթմների կիրառությունները (կանչերը) ապահովելու համար 
օգտագործվում է ալգորիթմի տիպը նկարագրող `Signature` դասը.

```kotlin
class Signature(
        val name: String,               // ալգորիթմի անունը
        val resultType: Type,           // արդյուքի տիպը
        val parametersTypes: List<Type> // պարամետրերի տիպերը
    ) { /* ... */ }
```

Փոփոխականների (անունների) տիպերի ներկայացման համար սահմանված է `Type` թվարկումը.

```kotlin
enum class Type(val text: String) {
    VOID(""),        // «դատարկ», արդյունք չստեղծող ալգորիթմների համար 
    REAL("ԻՐԱԿԱՆ"),  // կրկնակի ճշտության իրական թվեր
    TEXT("ՏԵՔՍՏ"),   // տեքստային մեծություններ
    BOOL("ԲՈՒԼՅԱՆ")  // տրամաբանական մեծություններ
}
```

__Ղեկավարող կառուցվածքների__՝ հրամանների ընտանիքի հիմքը `Statement` _sealed_[^1] 
դասն է. բոլոր հրամանները այս դասի ժառանգներն են։

```kotlin
sealed class Statement
```

Հրամանների _հաջորդականությունը_՝ `Sequence` պարզապես `Statement`-ների ցուցակ է.

```kotlin
class Sequence : Statement() {
    val items = arrayListOf<Statement>()
}
``` 

_Վերագրման_ հրամանը երկու անդամ ունի՝ սիմվոլ և վերագրվող արժեք.

```kotlin
class Assignment(val sym: Symbol, val value: Expression) : Statement()
```

Սիմվոլը՝ որին պիտի վերագրվի `value` արժեքը սահմանված է `Symbol` դասով.

```kotlin
class Symbol(
        val id: String, // անունը
        val type: Type  // տիպը
    )
```
 

_Ճյուղավորման_ կառուցվածքում պայմանն է՝ `condition`, պայմանի դրական լինելու դեպքում 
կատարվելու համար սահմանված հրամանների բլոկը՝ `decision` և այլընտրանքային հրամանների
բլոկը՝ `alternative`, որը պետք է կատարվի երբ պայմանը բացասական է։
 

```kotlin
class Branching(
        val condition: Expression,  // պայման
        val decision: Statement,    // դրական պայմանի հրամանները
        val alternative: Statement  // բացասական պայմանի հրամանները
    ) : Statement()
```

_Կրկնության_ կառուցվածքը նախապայմանով ցիկլ է. քանի դեռ `condition` պայմանը դրական է,
պետք է կատարվի `body` հրամանների բլոկը։

```kotlin
class Repetition(
        val condition: Expression, // կրկնության պայման
        val body: Statement        // հրամանների կրկնվող բլոկ
    ) : Statement()
```

Ալգորիթմի կատարման արդյունքը ներկայացնում է `Result` կառուցվածքը (նույնն է ինչ դասական 
`return` հրամանը)։

```kotlin
class Result(
        val value: Expression // ալգորիթմի արդյունքը
    ) : Statement()
```

Ալգորիթմի կիրառման ու որպես ֆունկցիայի կանչի կառուցվածքներն իրար նման են։ Հենց դրա 
համար էլ `Call` կառուցվածքն իրականացրել եմ որպես `Apply` արտահայտության _թաղանթ_ 
(կամ՝ wrapper):

```kotlin
class Call(
        callee: Signature,           // կիրառվղ ալգորիթմի նկարագրիչը
        arguments: List<Expression>  // կիրառման արգումենտները
    ) : Statement() {
    val apply = Apply(callee, arguments)
}
```

__Արտահայտությունների__ ընտանիքի հիմքում `Expression` sealed դասն է։ Այն ունի միակ 
հատկություն՝ արտահայտության տիպը։ 

```kotlin
sealed class Expression(
        val type: Type  // արտահայտության տիպը
    )
```

Թվային (իրական), տեքստային և տրամաբանական հաստատունները ներկայացված են համապատասխանաբար
`Numeric`, `Text` և `Logical` դասերով։ Դրանցից ամեն մեկը `Expression` դասի կոնստրուկտորին
է փոխանցում իր տիպը։

```kotlin
class Numeric(val value: Double) : Expression(Type.REAL) 
class Text(val value: String) : Expression(Type.TEXT) 
class Logical(val value: String) : Expression(Type.BOOL)
```

Ալգորիթմում հայտարարված ամեն մի փոփոխականի համար քերականական ծառում ստեղծվում է `Variable`
տիպի օբյեկտ.

```kotlin
class Variable(
        val sym: Symbol       // Փոփոխականի անունն ու տիպը 
    ) : Expression(sym.type)
```

Արտահայտություններն իրար են կապվում և ստեղծվում են ավելի բարդ արտահայտություններ՝ 
`Operation` թվարկմամբ սահմանված գործողություններով։

```kotlin
enum class Operation(val text: String) {
    ADD("+"),  // գումարում
    SUB("-"),  // հանում, նաև ունար մինուս
    MUL("*"),  // բազմապատկում
    DIV("/"),  // բաժանում

    EQ("="),   // հավասար է
    NE("<>"),  // հավասա չէ
    GT(">"),   // մեծ է
    GE(">="),  // մեծ է կամ հավասար
    LT("<"),   // փոքր է
    LE("<="),  // փոքր է կամ հավասար

    AND("ԵՎ"), // կոնյունկցիա
    OR("ԿԱՄ"), // դիզյունկցիա
    NOT("ՈՉ"); // ժխտւմ (ունար)
}
```

Միտեղանի (ունար) գործողության դասը երկու անդամ ունի. գործողության կոդը՝ `operation` 
և ենթակա արտահայտությունը՝ `right`։ `Unary` դասի կոնստրուկտորը ստանում է նաև `type` 
արժեքը, որը փոխանցվում է `Expression`-ի կոնստրուկտորին։

```kotlin
class Unary(
        val operation: Operation,
        type: Type,
        val right: Expression
    ) : Expression(type)
```

Երկտեղանի (բինար) գործողության մոդելը ներառում է գործողության կոդը, ինչպես նաև գործողության
նշանի աջ ու ձախ կողմերում գրածված արտահայտությունների ծառերը։ Այս դեպքում էլ նույնպես `type`
արժեքը փոխանցվում է `Expression`-ին։

```kotlin
class Binary(
        val operation: Operation,
        type: Type,
        val left: Expression,
        val right: Expression
    ) : Expression(type)
```

Բաղադրյալ արտահայտություններում կարող են մասնակցել նաև ֆունկցիա-ալգորիթմների կանչեր՝ ներկայացված
`Apply` դասով։ Սրա երկու անդամներն են կանչվող ալգորիթմի նկարագրիչը և կանչի արգումենտները։

```kotlin
class Apply(
        val callee: Signature,           // կանչվող ալգորիթմի նկարագրիչ
        val arguments: List<Expression>  // կանչի արգումենտներ
    ) : Expression(callee.resultType)
```

----
[^1]: Առայժմ չեմ գտնում `sealed class` տերմինի իմաստային թարգմանությունը։ Միգուցե՝ «փակ դաս»։


### Շարահյուսական վերլուծություն

### Նպտակային կոդի ստեղծում 


